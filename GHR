#!/usr/bin/env node

require('dotenv').config()
const fetch = require('isomorphic-unfetch')
const yaml = require('js-yaml')
const fs = require('fs')
const path = require('path')

const { GH_PERSONAL_TOKEN } = process.env
const API_URL = 'https://api.github.com'
const VERSION = 'application/vnd.github.v3+json'

const releasesFile = process.argv[2] ? process.argv[2] : './.releases.yml'
let releases = {}
try {
  releases = yaml.safeLoad(fs.readFileSync(path.join(__dirname, releasesFile), 'utf8'))
} catch (e) {
  console.error(e)
}

const getLatestRelease = async (org, repo) => {
  const release = await fetch(`${API_URL}/repos/${org}/${repo}/releases/latest`, {
    headers: {
      Accept: VERSION,
      Authorization: `Bearer ${GH_PERSONAL_TOKEN}`
    }
  })
    .then(r => r.json())
    .catch(e => console.error(e))
  return release
}

const createRelease = async (org, repo, release) => {
  const newRelease = await fetch(`${API_URL}/repos/${org}/${repo}/releases`, {
    method: 'POST',
    headers: {
      Accept: VERSION,
      Authorization: `Bearer ${GH_PERSONAL_TOKEN}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(release)
  })
    .then(r => r.json())
    .then(r => console.info('✅', `${org}/${repo}`, `${r.target_commitish}@${r.tag_name}`, r.name, r.body.split('\n')[0].length > 80 ? r.body.split('\n')[0].slice(80) : r.body.split('\n')[0]))
    .catch(e => console.error(e))
  return newRelease
}

(async () => {
  const promises = []

  for (const org in releases) {
    for (const repo in releases[org]) {
      const release = {
        tag_name: releases[org][repo].tag,
        name: releases[org][repo].name ? releases[org][repo].name : releases[org][repo].tag,
        body: releases[org][repo].body ? releases[org][repo].body : '',
        target_commitish: releases[org][repo].branch ? releases[org][repo].branch : 'master',
        draft: releases[org][repo].draft ? releases[org][repo].draft : false,
        prerelease: releases[org][repo].prerelease ? releases[org][repo].prerelease : false
      }

      const latestRes = await getLatestRelease(org, repo)
      let shouldCreate = false
      if (latestRes.message === 'Not Found' || latestRes.tag_name !== release.tag_name || latestRes.name !== release.name || latestRes.target_commitish !== release.target_commitish) {
        shouldCreate = true
      }
      if (shouldCreate) {
        promises.push(createRelease(org, repo, release))
      } else {
        promises.push(new Promise((resolve) => resolve()).then(() => console.info('☑️', `${org}/${repo}`, `${latestRes.target_commitish}@${latestRes.tag_name}`, latestRes.name, latestRes.body.split('\n')[0].length > 80 ? latestRes.body.split('\n')[0].slice(80) : latestRes.body.split('\n')[0])))
      }
    }
  }

  Promise.all(promises).then(() => console.info('Done')).catch(e => console.error(e))
})()
